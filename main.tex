\documentclass[5p]{elsarticle}
\usepackage{lineno,hyperref}
\modulolinenumbers[5]
\journal{Journal of Network and Computer Applications}

\usepackage{amsmath,amssymb,amsfonts,chemarrow,balance,booktabs}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{mathenv}
\usepackage{color}
\usepackage{multirow}
\usepackage{float}
\usepackage{threeparttable}
\usepackage[inline]{enumitem}
\usepackage{url}
\usepackage{hyperref}
\usepackage[linesnumbered,ruled,noend]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{bytefield}
\usepackage[table]{xcolor}



\newcommand{\BfPara}[1]{{\noindent\bf#1.}\xspace}
\newcommand{\bc}{{Bitcoin}\xspace}
\newcommand{\rc}{{{\em RouteChain}}\xspace}
\newcommand{\bcc}{{Blockchain}\xspace}
\newcommand{\Bbc}{{Blockchain}\xspace}
\newcommand{\etc}{{etc.}\xspace}
\newcommand{\eg}{{\em e.g.}\xspace}
\newcommand{\ie}{{\em i.e.,}\xspace}
\newcommand{\cc}{{cryptocurrency}\xspace}
\newcommand{\Cc}{{Cryptocurrency}\xspace}
\newcommand{\cj}{{cryptojacking}\xspace}
\newcommand{\Cj}{{Cryptojacking}\xspace}
\newcommand{\bt}{{{\em BlockTrail}}\xspace}


\newcommand{\ddos}{{DDoS}\xspace}
\newcommand*{\defeq}{\stackrel{\text{{\color{brown}def}}}{=}}
\newcommand{\tsref}[1]{\textsection\ref{#1}\xspace}
\newcommand{\todo}[1]{{\color{red}{[TODO: #1]}}}
\newcommand{\etal}{{\em et al.}\xspace}
\newcommand{\parag}[1]{{\noindent\bf#1}}
\newtheorem{condition}{\textbf{Condition}}
\newtheorem{theorem}{\textbf{Theorem}}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}


\definecolor{xgreen}{rgb}{0.2,0.6,0.0}
\definecolor{xred}{rgb}{0.7,0.1,0.0}
\def\equationautorefname~#1\null{(#1)\null}
\let\subsectionautorefname\sectionautorefname
\let\subsubsectionautorefname\sectionautorefname

\definecolor{light-gray}{gray}{0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}      
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}

\usepackage{amsmath}

\newcommand\JSONnumbervaluestyle{\color{blue}}
\newcommand\JSONstringvaluestyle{\color{blue}}
\newif\ifcolonfoundonthisline
\makeatletter


\lstdefinestyle{json}
{ backgroundcolor=\color{light-gray},
    basicstyle=\footnotesize\ttfamily,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
  showstringspaces    =false,
  keywords            = {false,true},
  commentstyle= \itshape\color{codegreen},
  alsoletter          =0123456789.,
  morestring          = [s]{"}{"},
  stringstyle         = \ifcolonfoundonthisline\JSONstringvaluestyle\fi,
  MoreSelectCharTable =%
    \lst@DefSaveDef{`:}\colon@json{\processColon@json},
 % basicstyle          = \ttfamily,
  keywordstyle        = \ttfamily\bfseries,
}


\newcommand\processColon@json{%
  \colon@json%
  \ifnum\lst@mode=\lst@Pmode%
    \global\colonfoundonthislinetrue%
  \fi
}


\hypersetup{
	plainpages=false,
	colorlinks,
	urlcolor=blue!50!black,
	linkcolor=red!50!black,
	citecolor=green!50!black,
	bookmarksnumbered
}


\bibliographystyle{elsarticle-num}

\begin{document}
\begin{frontmatter}
\title{\rc: Towards Blockchain-based \\Secure and Efficient BGP Routing}
\author[]{Muhammad Saad}
\ead{saad.ucf@knights.ucf.edu}
\author[]{Afsah Anwar}
\ead{afsahanwar@Knights.ucf.edu}
\author[]{Ashar Ahmad}
\ead{ashar@cs.ucf.edu}
\author[]{Hisham Alasmary}
\ead{hisham@Knights.ucf.edu}
\author[]{Murat Yuksel}
\ead{Murat.Yuksel@ucf.edu}
\author[]{David Mohaisen\corref{mycorrespondingauthor}}
\cortext[mycorrespondingauthor]{Corresponding author}
\ead{mohaisen@cs.ucf.edu}
\fntext[myfootnote]{This paper is an extension of an earlier work that appeared in IEEE International Conference on Blockchain and Cryptocurrency (ICBC 2019)~\cite{saad2019routechain}}



\address{University of Central Florida}


\begin{abstract}
Routing on the Internet is defined among autonomous systems (ASes) based on a weak trust model where it is assumed that ASes are honest. While this trust model strengthens the connectivity among ASes, it also results in an attack surface that can be exploited to hijack the routing paths. One such attack is known as the BGP prefix hijacking, in which a malicious AS broadcasts IP prefixes that belong to a target AS, thereby hijacking its traffic. In this paper, we propose \rc: a blockchain-based secure BGP routing system that counters BGP hijacking and maintains a consistent view of the Internet routing paths. Towards that, we leverage provenance assurance and tamper-proof properties of blockchains to augment trust among ASes. We group ASes based on their geographical (network) proximity and construct a bi-hierarchical blockchain model that detects false prefixes prior to their spread over the Internet. We evaluate \rc using three different consensus protocols and show its effectiveness by drawing a case study with the Youtube hijacking of 2008. Our results show that \rc can efficiently detect false prefix announcements and prevent BGP attacks over the Internet.    
\end{abstract}

\begin{keyword} Blockchain; Autonomous Systems; BGP; Distributed Systems\end{keyword}
\end{frontmatter}

\section{Introduction}\label{sec:introduction}
Data flows on the Internet between autonomous systems (ASes), which are connected in a peer-to-peer (P2P) topology~\cite{SpotoGM14,KanzakiF13}. Typically, an AS represents a collection of Internet Protocol (IP) prefixes, and to which data is routed~\cite{PadmanabhanL2001}. Due to P2P architecture, ASes require an effective communication protocol to maintain updated routing paths and monitor network changes. The semantics of this communication among ASes are determined by a standardized routing protocol called the Border Gateway Protocol (BGP) \cite{SermpezisKDD18}. Although efficient in practice, BGP is broadly based on a weak trust model, whereby ASes assume that their neighboring ASes behave honestly and propagate correct routing information. However, sometimes interests of ASes (i.e., networking operators managing them) can be in conflict, and this weak notion of trust can be breached by malicious ASes. As a result, this opens the door for attacks whereby malicious ASes may attempt to hijack the traffic of a target AS. A well-known attack that captures this exploitation of trust is known as the ``BGP prefix hijacking'' or simply the BGP hijacking~\cite{MitsevaPE18,JonkerPDS18}. 

In BGP hijacking, a malicious AS announces fake (impersonated or unreachable) IP prefixes that belong to a target AS. Conforming to the expectations of honesty and trustworthiness, neighboring ASes accept those prefixes and modify their routing paths for reachability. They further propagate the prefixes to their neighboring ASes. As the BGP announcement traverses across ASes, they update their routing tables according to the values in the announcement. Eventually, as the routing converges, the traffic destined for the legitimate AS---an AS that owns the announced prefix---gets diverted to the malicious AS, thereby causing a traffic hijacking. The redirected traffic does not reach the correct destination, thereby causing revenue and reputation losses. 



Although various solutions have been proposed to preventing the BGP prefix hijacking attacks, including BGPSec and RPKI, those solutions have not been deployed widely in practice~\cite{QiuGRN07}, making these attacks possible for the Internet's critical functionality of routing. A key reason behind this is that these solutions take a clean-slate approach towards redesigning routing protocols and policies, by introducing additional infrastructure for their operation. However, due to the capital invested in the existing Internet infrastructure, ASes and ISPs are reluctant to migrate towards these solutions despite the known security threats and their clear benefits. 

% This is a major inhibition in migrating towards a new protocol scheme which would require a system-wide overhauling of current Internet architecture. Therefore, ISPs and ASes continue to function in the conventional ways despite security risks.  

Embracing the policy-based functional challenges as well as the security risks in routing, we propose a new framework called \rc, which counters BGP attacks by using blockchains. Blockchains have introduced secure and robust ways of augmenting trust in distributed systems. Through secure-by-design protocols, blockchains enable tamper-proof data management without the need of a trusted intermediary. ASes broadly reflect a distributed mesh of interconnected systems, that often lack consensus over correct protocol execution. It is therefore intuitive to bring blockchain to the design space of ASes management in order to upgrade their security while maintaining operational consistency. \rc explores the usefulness of blockchains for BGP. 

In \rc, we treat a BGP announcement as a transaction, and {\color{blue} record each announcement in a blockchain ledger shared among the peers (ASes). To maintain a consistent blockchain, ASes execute a consensus protocol which specifies the {\em correct} blockchain state and prevents malicious announcements from propagating in the network. Blockchains use various consensus protocols to maintain consistency. In \rc, we use Proof-of-Stake (PoS), Proof-of-Authority (PoA), and Proof-of-Elapsed Time (PoET)~\cite{BanoSAAMMD17,Angelis18,SaadSNKSNM20} due to their high fault tolerance and low transaction confirmation time. We develop a blockchain testbed to evaluate the performance of \rc in the wild. Our testbed consists of nodes hosted across different ASes and we evaluate the time they take to validate the correctness of a new BGP announcement. 





The premise of our work relies upon a consensus agreement among ASes, prior to the launching of an attack. To that end, we contrast the timings of known BGP attack on Youtube, with the consensus time in \rc. Our results show that while all consensus protocols meet the baseline requirement of preventing the attack, in particular, {\em Clique} (a PoA-based protocol) achieves the lowest transaction confirmation time and the maximum transaction throughput.} \rc is incrementally deployable and backwards compatible with the current operations of ASes. ASes can use it in parallel with their current routing policies as an additional security feature. Therefore, \rc does not require ASes to switch from legacy systems to a new protocol paradigm. 


\BfPara{Contributions} We make the following contributions:
\begin{enumerate*}
    \item We introduce a blockchain-based system called \rc that prevents BGP hijacking.
    \item We set up a testbed in different ASes across the world and evaluate \rc's performance under three blockchain consensus protocols. 
    \item Our experiments show that \rc can neutralize a BGP hijack attempt in all three consensus protocols. Among them, {\em Clique} achieves the best performance due to minimum transaction confirmation latency. 
    \item We further demonstrate \rc feasibility by drawing a case study from the well-known Youtube's BGP hijacking case, where \rc is shown to neutralize the attack.  
    \item Our proposed solution is shown to be incrementally deployable; easily implemented alongside existing protocols. 
\end{enumerate*}

\BfPara{Organization} The rest of the paper is organized as follow. In \textsection\ref{sec:bg}, we provide the background and preliminaries of our work. In \textsection\ref{sec:ps}, we introduce the problem statement, the threat model, the motivation, and the methodology. In \textsection\ref{sec:rc}, we present our proposed solution \rc, along with its design and analysis. In \textsection\ref{sec:simulation}, we present the simulations and results. In \textsection\ref{sec:discussion}, we discuss the advantages and limitations of our work. That is followed by related work and conclusion in \textsection\ref{sec:rw} and \textsection\ref{sec:conclusion}.  




\section{Background and Preliminaries}\label{sec:bg}
In this section, we briefly review the background of ASes, BGP, and blockchains, aligned with the scope of this work. 

\subsection{Autonomous Systems and BGP} \label{sec:AS}
\BfPara{ASes} The Internet is composed of interconnected entities that forward data from a source to a destination. These entities can range from small local area network (LAN) switches, ASes that connect geographically distributed communication devices and networks. 

An AS is a collection of connected routers whose IP prefixes are assigned to an Internet Service Provider (ISP). These routers adhere to the routing policy defined by the ISP. Every AS on the Internet is assigned a unique Autonomous System Number (ASN), which is used as an identifier in inter-AS, a.k.a. inter-domain, routing. An AS is responsible for routing the traffic among networks hosted by itself and other networks hosted by its neighboring ASes. For that, an AS uses the Interior Gateway Protocol (IGP) to enable communication among its internal routers attached to networks it is hosting, and the Exterior Gateway Protocol (EGP) to reach the routers in the neighboring ASes. Inter-AS relationships are established according to economic or business relationships among ISPs owning ASes. The relationship between two neighboring ASes can be peering or customer-provider engagement, and typically means that a level of trust exists between them.  
%(peers, customers, or providers). Each router maintains routing tables to identify and monitor routing paths. 


\BfPara{BGP}
The Border Gateway Protocol (BGP) is a standard protocol that is designed to connect edge routers between two neighboring ASes. BGP enables the propagation of reachability and routing information from one AS to another~\cite{rfc4271}. It is also used for routing information within the AS itself. BGP operates in two ways: It uses interior BGP (iBGP) for routing among the network peers within an AS, and the external BGP (eBGP) for routing to/from other ASes~\cite{rfc4271,SmithG96}. In this paper, we are concerned with eBGP that pivots communication among edge routers of neighboring ASes. \autoref{fig:ASes} shows the connection of routers within and outside the ASes. The bold circles represent the edge routers that are connected to either the internal or external routers through the BGP protocol. %%what's the difference between 

\BfPara{BGP Attacks}\label{bgp:attacks}
The exploitation of trust among neighboring ASes leads to BGP attacks. These attacks can be broadly classified into two types: partial attack and complete attack~\cite{BGPHijack}. The partial attack occurs when an adversarial AS announces an identical IP prefix as that of the victim AS. One such attack was launched on Youtube on February 24th, 2008, by an ISP that owned AS17577~\cite{BiersackJFFTTTV12,WongS11}. AS17577 started to announce the prefix 208.65.153.0/24---which actually belonged to the Youtube AS36561---to its upstream provider AS3491. AS3491 further propagated the prefix to its neighboring ASes, leading to the Youtube hijacking. In the partial hijacking, the adversary has no significant advantage over the victim. Since the two announcements are the same, therefore when any AS receives the announcement, it can either switch to it or continue with the old routing path based on the path length. 

In complete attacks, the adversarial AS announces more specific prefixes than the target AS. Since the default forwarding scheme is based on longest prefix matching, ASes switch to more specific prefixes. Therefore, when an adversary announces more specific prefixes, any AS that receives the announcement inevitably switches to the new routing path. Therefore, in this attack, the adversary has a significant advantage over the victim~\cite{BGPHijack}.The upside in this attack is that the adversary can only hijack a portion of the traffic destined to an AS since it has to announce a longer prefix.

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.30\textwidth]{fig/ASes.pdf}
%\vspace{-12mm}
\caption{An overview of ASes connected to one another. In AS 1--4, the circles inside represent routers that are responsible for intra-AS routing. Bold circles represent the border routers that are connected to other border routers through BGP protocol. To emphasize their connectivity, we color them in dark.  } 
\label{fig:ASes}
\end{center}

\end{figure}


\subsection{Blockchains} \label{sec:BC}
Blockchain technology has introduced a new paradigm in distributed systems with applications spanning cryptocurrencies, smart contracts, distributed provenance, and censorship resistance~\cite{NeisseSN17,Omohundro14,GovernatoriIMRS18,AhmadSBM18}. With promising guarantees including immutable and append-only data management in a decentralized system, blockchains are well suited to create provenance and prevent fraud in a trust-less environment. 

Blockchains use various consensus protocols to arbitrate trust among networks and entities. Some of the well-known consensus protocols include the proof-of-work (PoW), proof-of-stake (PoS), proof-of-elapsed time (PoET), proof-of-authority (PoA), and the practical Byzantine fault tolerance (PBFT) \cite{SaadM18,SaadNKM18}. Each consensus protocol its benefits and limitations which we show in~\autoref{tab:ca}. Among the five consensus protocols, we selected PoS, PoA ({\em Clique}), and PoET for \rc due to (1) high scalability, (2) energy efficiency, (3) scalability, and (4) high throughput.  In the following, we briefly describe key features of the three conseneus protocols.  


\begin{table*}
\centering
\caption{Comparison of the consensus protocols used in blockchain systems. The values reported in the table are obtained from prior works in \cite{nakamoto2008bitcoin,weipplCCS2016,sompolinsky2013accelerating}. }
\label{tab:ca} 
\scalebox{0.99}{
\begin{tabular}{l|c|c|c|c|c}
\textbf{Properties}  & \textbf{PoW}       & \textbf{PoS}       & \textbf{PBFT}  & \textbf{{\em Clique}}   & \textbf{PoET}  \\ \hline
\textbf{\begin{tabular}[c]{@{}l@{}}Blockchain Type\\ \end{tabular}}         & Permisssionless & Permissionless & Permissioned & Permissioned & Permissionless       \\ \hline
\textbf{\begin{tabular}[c]{@{}l@{}}Trust Model\\ \end{tabular}} & Untrusted & Untrusted &  Semi-trusted & Semi-trusted & Untrusted \\ \hline
\textbf{Scalability}                                                         & High               & High                      & Low  & High & High                      \\ \hline
\textbf{Throughput}                                                          & \textless{}10      & \textless{}1,000 &  \textless{}10,000  & - - &1,000 \\ \hline
\textbf{\begin{tabular}[c]{@{}l@{}}Fault Tolerance\\ \end{tabular}} & 50\%               & 50\%                      & 33\%  & 50\% & 50\%                            \\ \hline
\textbf{\begin{tabular}[c]{@{}l@{}}Energy Efficient\\\end{tabular}}         & No & Yes & Yes   & Yes & Yes      \\ \hline

\end{tabular}}
\end{table*}
 tailored to meet the design goals of our system. 



% \begin{figure}[t]
% \centering
% \includegraphics[width=0.45\textwidth]{fig/bgp_{\em Clique}_roundrobin.pdf}

% \caption{{\em Clique} uses a round-robin scheme to select primary node, and two secondary nodes, the primary is responsible for proposing a new block. In case of failure of a primary node the block is proposed by the secondary nodes. Note: R1 is the primary and R2 and R3 and secondary for the first epoch, for the second epoch R2 is the primary and R3 and R4 and the secondary. }
% \label{fig:{\em Clique}}
% \end{figure}

{\color{blue}{
\BfPara{{\em Clique}} \label{sec:cq}
{\em Clique} is a PoA-based consensus protocol that is fast, scalable, and has a high fault tolerance. In {\em Clique}, a primary replica is selected to order transactions in a block and broadcast that block to the other nodes. Although the process of transaction ordering is similar to PBFT, however, {\em Clique} relies on {\em eventual consistency} which reduces the message complexity from  $O(n^2)$ to  $O(1)$, thus favoring scalability. Moreover, unlike PBFT, {\em Clique} has a high fault tolerance and it can tolerate up to $f/2$ faulty replicas. In other words, {\em Clique} can prevent a BGP hijack as long as 50\% ASes behave honestly, which is a fair assumption to make in practice. 




\BfPara{{\em PoS}} \label{sec:pos}
The PoS protocol is similar to an auction process in which the each participant bids for a block. The participant with the highest bid is allowed to order transactions and release them to the rest of the network. PoS can be realized in \rc by assigning fixed tokens to each AS and the AS using those tokens order routes in the block. For correct ordering (\ie non-malicious BGP announcements), the AS can be rewarded more tokens to promote the honest behavior. As shown in~\autoref{tab:ca}, as long as no AS possesses a majority of tokens, PoS-based \rc construction will be able to prevent the BGP hijack. 

\BfPara{{\em PoET}} \label{sec:poet}
PoET leverages the security properties of Trusted Execution Environment (TEE) to randomly elect a leader in the network who then orders transactions and proposes a block. PoET is currently deployed in the Hyperledger Sawtooth using Intel Software Guard Extensions (SGX)\cite{Sawtooth}.  The randomized nature of leader election ensures decentralization and guarantees the blockchain consistency under the honest majority assumption. 




}}

\section{Problem Statement and Threat Model}\label{sec:ps}
In the following, we describe our problem statement along with the threat model. Using this model, we build the motivation and describe the methodology of our work.

\subsection{Problem Statement} \label{sec:psn}
Broadly speaking, the problem with routing attacks on ASes involves the exploitation of a weak trust model that parameterizes the communication among ASes. Each AS has its own routing table at the the gateway router, which only includes routing information of the ASes that are directly connected to it. Moreover, when a new  piece of routing information is presented to the AS---that is not in conflict with its own routing policies---it readily accepts them and sets its outbound traffic to the new path. Moreover, the router at the gateway is unaware of the routing paths maintained by neighboring ASes. Lacking a global knowledge obstructs the detection of a malicious routing path when propagated. Therefore, the lack of a synchronized global knowledge along with a weak trust model lead to the routing attacks. Although those attacks are infrequent, their impact could be catastrophic, making them important to address. 

Another challenge in preventing BGP hijacking is the cost associated with the existing countermeasures. For instance, one of the well-known countermeasures is the use of ``Resource Public Key Infrastructure'' (RPKI) \cite{rfc8481}, which enables network operators to cryptographically authorize ASes the to announce a specific prefix. To effectively use RPKI, ASes set up a route assigning authority called ``Routing Origin Authorization'' (ROA), that overlooks prefix authorization. While promising in theory, RPKI has some practical limitations. First, it requires all ASes to become part of a central authority and conform to its policies. In a decentralized network of over 80,000 ASes---each with a different functional policy---achieving this agreement can be challenging. Second, this clean-slate approach towards design and deployment of routing schemes may not be acceptable to network operators. 

\subsection{Threat Model} \label{sec:tm}
For BGP attacks, we assume the adversary to be a malicious AS or a group of ASes, aiming to hijack traffic of a target AS. The adversary can either launch a partial hijacking by announcing an identical prefix, or launch a complete hijacking by announcing more precise IP prefixes of the victim AS (\textsection\ref{bgp:attacks}). The adversary will exploit the weak trust model of its neighboring ASes, and expect them to change their routing paths accordingly. After announcement to the neighboring ASes, the adversary will hope its prefixes propagate swiftly through other ASes to maximize the attack severity. 

Assuming a victim is a valuable AS (i.e., an AS of interest to the adversary), hosting nodes that contain sensitive or valuable information, such as Bitcoin mining pools, then a large-scale attack can be launched to eclipse the target AS. In this attack, multiple ASes can simultaneously launch a complete or partial BGP attack, thereby hindering the recovery process of the victim. In such a situation, the attack may persist for a long time, causing excessive revenue and reputation loss~\cite{BangeraG11}.



\subsection{Motivation}\label{sec:motivation}
The motivation of this work is to introduce a blockchain-based routing scheme to prevent BGP attacks. We intend to use the tamper-proof guarantees of blockchains to equip routing tables with an immutable ledger that tracks routing paths. Therefore, when a malicious AS announces false prefixes, the rest of the network is able to detect and discard them. Moreover, keeping in view the need of a swift consensus, we aim to design \rc in a hierarchical way to improve performance and reduce latency. At the time of writing this work, there are 88,721 ASes on the Internet~\cite{RIR-18}, and using {\em Clique} to achieve consensus among them over a single routing path will lead to significant delays and unnecessary processing overhead. To avoid that, we intend to explore new design parameters that can be tailored to the efficiency requirements of the system.  Finally, a major effort in this work has been dedicated towards the incremental deployment of \rc: our objective is to achieve a standalone system that can be integrated with the current {\em Modus Operandi} of ASes and does not require them to modify their policies. 


\subsection{Methodology}\label{sec:method}
First we explore possible ways in which \rc can be structured to meet the requirements of {\em Clique}. We design our system in such a way that the consensus time among ASes is less than the time of hijacking. To that end, we set Youtube hijacking of 2008~\cite{GoldbergS14} as our baseline attack model to derive the hijacking time. Next, we compare the consensus time in \rc with the hijacking time obtained from the baseline attack model to analyze the strength of our design in adversarial settings. We do that by carrying event driven simulations that mimic the real-world conditions of the Internet. Since \rc is a modular structure, we tailor its design to achieve consensus over routes in minimum time. 




\section{\rc}\label{sec:rc}
In this section, we present the design and analysis of \rc. In \autoref{tab:one}, we provide the notations that will be used throughout the rest of the paper.  


{\def\arraystretch{1}
\begin{table}\caption{Symbols and Definition}
\centering
\scalebox{0.95}{
\begin{tabular}{l|l} 
\hline 
\textbf{Symbols} & \textbf{Definition} \\
\hline
$A$  & ASes in world $A = { a_{1},a_{2},...a_{n}}$\\
$K$  & ASes subgroups $K ={k_{1},k_{2},...,k_{p}}$, where $p\leq n$ \\ 
$\mathcal{A}$  &  A group of one or more adversarial ASes\\
$\mathcal{V}$  &  Victim AS to be hijacked by $\mathcal{A}$ \\
$\mathcal{B}_{A}$  &  Global blockchain for $A$\\ 
$\mathcal{T}_{A}$  &  Global blockchain consensus time for $\mathcal{B}_{A}$ \\
$\mathcal{B}_{K}$  & Subgroup blockchains, $\mathcal{B}_{K} {\mathcal{B}_{k_{1}},\mathcal{B}_{k_{2}},...\mathcal{B}_{k_{p}}}$  \\
$\mathcal{P}_{A}$ & Global primary replica for $\mathcal{B}_{A}$\\
$\mathcal{P}_{k_{i}}$ & Subgroup primary replica for $k_{i}$, where $1\leq i\leq p$\\
$\mathcal{T}_{K}$  & ASes consensus time in a subgroup \\
$\mathcal{T}_{A}$  & Consensus time in global blockchain \\
$\mathcal{T}_{E}$  &  End-to-end transaction delay \\
$\mathcal{T}_{h}$  &  Time to hijack target AS \\
$\mathcal{T}_{p}$  &  communication time between two ASes. \\
$\mathcal{T}_{v}$  &  Blockchain verification time \\
\hline
\end{tabular}}
\label{tab:one}
\end{table} } 

\subsection{System Architecture}\label{sec:do}
The overall design of \rc involves all ASes $A$ sharded into $K$ subgroups, with each subgroup sharing a single ledger. Subgroups are constructed based on their geographical proximity in order to reduce propagation delays and achieve faster consensus. Within a subgroup, each AS will maintain a subgroup ledger to keep track of routing paths that belong to all ASes within the subgroup. Having such a transparent and consistent view ensures that if any AS is targeted within the subgroup, all other ASes will be able to detect that, and take preventive measures. 

Our choice of sharding ASes into groups has multiple benefits. First, maintaining a single ledger for all ASes on the Internet can have a significant storage overhead, since each AS will be forced to maintain and update the routing information of all other ASes.  % Since routing paths are updated frequently, therefore, in an append-only model of blockchains, this would require a frequent update of ledger at each AS. % Furthermore, as the blockchain size will grow, the time to verify a new transaction will also increase. For a system of over 80,000 peers, having a single ledger would be computationally expensive along with an increasing storage overhead. 
Second, as the blockchain size grows, the time required to validate the correctness of a new transaction increases. For each new transaction, an AS would need to check the entire blockchain to view the prior history of a path defined in the new transaction. This verification time is critical, since it contributes to the overall consensus time. Having a long single ledger would increase the verification time for each incoming transaction. 

Finally, the key challenge in \rc is to obtain consensus of peers over a new route before the convergence of the legacy system. As mentioned in \textsection\ref{sec:motivation}, \rc will be deployed in parallel to the legacy system, therefore our objective is to flag a bogus route before it propagates through the legacy system and leads to a hijack. In \rc, subgroups will enable a parallel processing over a new transaction. Since ASes in subgroups are associated based on their geographical (network) proximity, they can achieve faster consensus due to low propagation delays for any given transaction. As such, parallel processing within subgroups will reduce the overall consensus time, as opposed to a flat blockchain system composed of all ASes. As such, sharding ASes in subgroups is a useful for fast consensus over BGP routes. 

For provenance assurance and a globally consistent view, \rc also maintains a global blockchain shared among subgroups. The global chain one maintains decisions on a given transaction, and does not contain detailed information of routing paths. For instance, when an AS announces his prefixes in a transaction, once the transaction gets approved by subgroups, the concerned subgroup updates its routing table while the global chain locks the transaction approval. The global chain will have all the announcements that are made by ASes in the form of a transaction. Therefore, when a new transaction is issued by an adversarial AS, the global blockchain can be consulted to track the true owner of those prefixes. The global chain however, does not include the routing paths that are maintained at the routers of an AS. 

In summary, \rc is a bi-hierarchical blockchain system, consisting of a global chain shared among subgroups, and subgroup chains shared among ASes. Once a transaction is generated, it is forwarded to subgroups, and upon receiving approvals, its status is updated in the ledgers (\textsection\ref{sec:SA}).   


\subsection{Subgroup Structure}\label{sec:sg}
% The subgroups are actuated based on their geographical locality. For instance, if we have to form two groups of ASes in \autoref{fig:ASes}, then ISP A, B, and C can form one group due to their spatial closeness, while ISPs E, F, and D, can form another group. These groups will have to blockchains to manage their routing paths. One blockchain will be local to the group of ASes, while the other blockchain will be global chain that will record the routes shared among all the groups of ASes. The subgroup size is adjustable to meet the timing constraint of consensus. 

A subgroup will consist of multiple ASes with a shared ledger of routing paths. The selection of ASes for a subgroup can be achieved through various design choices. For instance, grouping ASes based on their geographical proximity can reduce propagation delays. On the other hand, grouping them based on their transit relationships can have less policy conflicts. \rc is agnostic towards the policy of forming subgroups as long as each subgroup shares a single ledger. In this paper, we assume the peer relationship to be driven by the incentive of geographical proximity and low delays~\cite{rfc1930}. However, as part of our future work, we will explore other mechanisms to that be adopted for better results. In \autoref{fig:ASes_SG}, we illustrate how four ASes from \autoref{fig:ASes} can be arranged into two subgroups. 

In \textsection\ref{sec:mind}, we derive optimal value of the number of subgroups $K$, that results in minimum delays for consensus. Since the Internet architecture is continuously evolving and the network typologies change with time, therefore we accommodate this changing modularity in \rc by keeping the subgroup size and number of subgroups flexible. For instance, let $|k_{max}|$ be the upper size limit of a subgroup. If a group of new ASes falls into the same geographical proximity, and its addition would breach the size limit, then two subgroups can be extracted from the same subgroup.  




\begin{figure}[t]
\begin{center}
\includegraphics[width=0.30\textwidth]{fig/ASes_SG.pdf}
\caption{An overview of subgroup ASes. SG-1 is a subgroup with two ASes, AS 1 and AS 2 in close proximity. SG-2 is another subgroup of two ASes, AS 3 and AS 4 in close proximity. Selection of subgroups can be made on any other scheme such as transit route policy.} 
\label{fig:ASes_SG}
\end{center}
\end{figure}

% \begin{figure}[t]
% \begin{center}
% \includegraphics[width=0.45\textwidth]{fig/bgp_clique.pdf}
% \caption{Fork in clique consensus protocol, $AS_2$ is the primary replica who broadcasts a block. Due to delays and latency  $AS_4$ does not get the block on time. Instead it receives the block published by the next primary $AS_3$. This leads to a fork. The fork can be resolved easily by mapping the prior known identity of the primary with the expected block. } 
% \label{fig:Clique_fork}
% \end{center}
% \end{figure}



\subsection{Consensus Mechanism}\label{sec:consen}


As mentioned in \textsection\ref{sec:cq}, in use three consensus protocols in \rc. Based on each protocol's specifications, a primary replica $\mathcal{P}_{K}$ is selected from each subgroup $K$ to send transactions to other replicas (ASes). $\mathcal{P}_{K}$ is responsible for receiving transactions, ordering transactions, computing a block, and broadcasting it to the other replicas. This process is carried out in one epoch, and at each epoch, a new primary is selected to continue the procedure. 



\BfPara{Transaction Data Structure}\label{secc:tds}
In \autoref{fig:packet}, we show the data structure of transaction generated by an AS. The transaction consists of a transaction ID field, an autonomous system number (ASN) field, and the BGP packet. For details on the structure of BGP packet, we refer the reader to~\cite{rfc4271} Once this transaction gets approved, it is updated in the global blockchain ledger. 


\begin{figure}[t]
\begin{center}
\includegraphics[width=0.40\textwidth]{fig/packet.pdf}
\caption{Transaction data structure in \rc. The unique identifier is used to for each transaction. Autonomous system number (ASN) field identifies the advertising AS, and BGP packet holds the metadata of routing information. } 
\label{fig:packet}
\end{center}
\end{figure}

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.40\textwidth]{fig/blockchain.pdf}
\caption{Blockchain data structure for a subgroup in \rc. The block contains a timestamp, hash of the previous block, and block payload. Block payload includes autonomous systems and their routes. All ASes within a subgroup have a transparent view of routes that belong to each AS. } 
\label{fig:packet_bc}
\end{center}
\end{figure}




\BfPara{Blockchain Data Structure}
In \autoref{fig:packet_bc}, we provide the structure of the blockchain for each subgroup. The blockchain consists of a timestamp that shows the time of block publication. The block also has a unique primary Id, and the hash of a previous block. In the block payload, we have all the ASes along with their complete routing paths. When a new block is computed, the routing paths are updated based on the newly approved transaction.

This blockchain data structure makes all ASes within a subgroup see all the BGP announcements. Based on import and export policies, the ASes may not want to re-advertise a path announcement. Also, an AS may do AS-PATH padding to increase the hop length of a path because it desires this path not to be used. But, our blockchain-based approach will effectively force all ASes in a subgroup to (i) re-advertise all the path announcements they received and (ii) use shortest possible paths. Although this may limit the flexibility in the import and export policies of individual ASes, it is an acceptable approach as the ASes in the same subgroup will likely trust each other and will not have an issue with sharing their prefix announcements. It is an open problem to design the blockchain data structure in a way that an AS advertising a path may choose to keep its announcement (or certain parts of it) encrypted while still adding it to blockchain for origin authorization purposes.






\subsection{Analysis of {\em RouteChain}} \label{sec:ana}
In this section, we perform analysis of \rc in terms of design requirements and performance objectives. 
\subsubsection{Design Analysis}\label{sec:da}
In \rc, the primary replica not only sends transactions to other replicas but also awaits an approval response. Additionally, the blockchain of a subgroup gets updated only if the approved transaction concerns the routing paths of ASes within the subgroup. Otherwise, only the subgroup decision is sent back to the global primary. We take this approach for two reasons. First, a subgroup must only update its blockchain if a transaction directly concerns its routing path. Otherwise,  maintaining routing paths of other subgroups is an unnecessary overhead. Second, this also reduces the size of the blockchain, making transaction verification faster. 

The process of obtaining transaction approval involves:
\begin{enumerate*}
    \item An AS broadcasting transaction to its subgroup primary $\mathcal{P}_{K_{i}}$,
    \item $\mathcal{P}_{K_{i}}$ forwarding transaction to the global primary $\mathcal{P}_{A}$,
    \item $\mathcal{P}_{A}$ broadcasting transaction to all subgroups $K$, 
    \item $\mathcal{P}_{K_{i}}$ obtaining at least $|k_{i}|/2$ responses from subgroup replicas,
    \item and $\mathcal{P}_{A}$ obtaining responses from $|K|/2$ subgroups
\end{enumerate*}

For consensus within a subgroup, the primary will take one propagation delay $\mathcal{T}_{p}$ to broadcast the transaction to all replica ASes. Each AS will take the verification time $\mathcal{T}_{v}$ to verify transaction from the blockchain, and $\mathcal{T}_{p}$ to send back the response to the primary. However, due to varying link conditions and verification capacities, the overall time of receiving $|k_{i}|/2$ responses might incur non-uniform delays. We characterize such delays with parameter  $\epsilon_{1}$. Therefore, for a given transaction, the consensus time $\mathcal{T}_{K}$ of a subgroup can be calculated as follows: 
\begin{align} \label{eq:1}
    \mathcal{T}_{K} = \mathcal{T}_{p} +  \mathcal{T}_{v} + \mathcal{T}_{p} + \epsilon_{1} = \mathcal{T}_{v} + 2\mathcal{T}_{p} + \epsilon_{1}
\end{align}


In the second phase of transaction confirmation, the global primary $\mathcal{P}_{A}$ needs to obtain $|K|/2$ responses from subgroup primaries. Similar to \autoref{eq:1}, the time to achieve this consensus would be the verification time, the propagation time, and the second overhead $\epsilon_{2}$, capturing random delays for information propagation between subgroups and the global primary. Therefore, the transaction confirmation time $\mathcal{T}_{A}$, for the global blockchain $\mathcal{B}_{A}$ can be calculated as follows:
\begin{align}\label{eq:2}
    \mathcal{T}_{A} = \mathcal{T}_{K}+ \mathcal{T}_{p}+\epsilon_{2} = \mathcal{T}_{v} + 3\mathcal{T}_{p} + (\epsilon_{1}+\epsilon_{2})
\end{align}



In a complete transaction life cycle, the transaction will start from an AS within a subgroup and through will reach the global primary through the subgroup primary. Once received, the the global primary will initiate the verification process by broadcasting transactions to all subgroups. Taking into account propagation delays at each step, the end-to-end duration of a transaction $\mathcal{T}_{E}$ can be calculated as follows: 

\begin{align}\label{eq:3}
    \mathcal{T}_{E} = 3\mathcal{T}_{p} +\mathcal{T}_{K}+ \mathcal{T}_{A} = \mathcal{T}_{v} + 6\mathcal{T}_{p} + (\epsilon_{1}+\epsilon_{2})
\end{align}

 


\BfPara{Minimizing Delay}\label{sec:mind}
To defend against BGP attacks, we want the value of $ \mathcal{T}_{E}$ to be small. From \autoref{eq:3}, it can be observed that propagation delays  $\mathcal{T}_{p}$ linearly contribute the most towards the end-to-end duration of transaction confirmation $\mathcal{T}_{E}$. Therefore, in order to reduce the number of propagation delays, we need to reduce the number of messages required to process a transaction. This depends upon the number of ASes in a subgroup, and the total number of subgroups respectively. We note that in \rc, $N/2$ messages are required by the primary to commit a transaction (\textsection\ref{sec:consen}). This means that $\mathcal{P}_{A}$ requires approval from 50\% replicas in both hierarchies. If we fix, $K$ subgroups for \rc, the size of each subgroup will be $A/K$, and the number of approvals required will be $A/2K$, since approvals among the subgroups will happen in parallel. Next, $\mathcal{P}_{A}$ also require approvals from $K/2$ subgroups for the global blockchain. Therefore, for a transaction confirmation, in total, $\mathcal{P}_{A}$ requires $A/2K + K/2$ approvals. For simplicity, we assume that each subgroup is uniform in size such that $|k_{1}|=|k_{2}|=|k_{p}|$. Using that and after simplification, we obtain the following equation that shows the total number of approvals required for the transaction commitment $\mathcal{C}$. 
\begin{align}\label{eq:4}
\mathcal{C} = \frac{A }{2K} + \frac{K}{2}= \frac{A + K^{2}}{2K}
\end{align}

From \autoref{eq:4}, our objective is to find the suitable value of $K$ that yields minimum value of $\mathcal{C}$. Therefore, by differentiating \autoref{eq:4} with respect to $K$, and setting it to $0$, we obtain the optimum value of $K$ as:  $K^* = \sqrt{A}$.  Note that $K^*$ is independent of the fact that the protocol requires half of the ASes to respond. This simplifies the design and $K^* = \sqrt{A}$ becomes an optimum target as the AS count $A$ changes. After plugging $A$ = 88,721, the total number of ASes in the world, we get $K^* \approx$ 298. This means that with number of subgroups fixed at 298, we will need minimum number of approvals for a transaction commitment. Minimum approvals will naturally have minimum propagation delays, which serves our main goal in \rc. 

\subsection{Security Analysis}\label{sec:SA}
In this section, we will analyze security properties of \rc in the light of the threat model. An adversary controlling one or more ASes will try to launch a partial or complete BGP attack on a target AS. In the following, we show how \rc defends against these attacks. 

\BfPara{Partial Attack} In a partial hijacking attack, the adversarial AS $\mathcal{A}$ announces identical BGP prefix that belongs to the victim AS $\mathcal{V}$. In the taxonomy of blockchains, this attack can be considered as double-spending, since $\mathcal{A}$ is trying to utilize a resource that is already being consumed by $\mathcal{V}$. As shown in \autoref{fig:packet}, the transaction will have the same BGP packet as payload but a conflicting value in ASN field. Since the global blockchain $\mathcal{B}_{A}$ will have a prior transaction of same prefixes linked to the identity of $\mathcal{V}$, such an anomaly can be easily detected in \rc. 

If $\mathcal{V}$ and $\mathcal{A}$ belong to the same subgroup, the hijacking attempt will be neutralized immediately by the subgroup primary $\mathcal{P}_{K_{i}}$, unless $\mathcal{A}$ is itself the primary. In such a case, the transaction will be sent to the the global primary $\mathcal{P}_{A}$. Also if $\mathcal{A}$ and $\mathcal{V}$ belong to different subgroups, the transaction will be forwarded to the $\mathcal{P}_{A}$ by $\mathcal{P}_{K_{i}}$. In both cases, the subgroup primaries will consult the global blockchain $\mathcal{B}_{A}$, and be able to spot the double-spent transaction. To defend against partial attacks, the response from subgroup primaries would be sufficient to obtain consensus over the transaction. As long as 50\% of the subgroup primaries behave honestly, a partial hijacking can be detected and countered immediately.  

\BfPara{Complete Attack} In a complete attack, $\mathcal{A}$ announces more specific prefixes than the ones owned by $\mathcal{V}$. As such, this behavior cannot be immediately detected as a double-spent transaction since $\mathcal{B}_{A}$ will not have a prior transaction linked to $\mathcal{V}$ that contains prefixes announced by $\mathcal{A}$. To detect that, \rc would require a conflict resolution from all ASes in subgroups. Each AS will consult their subgroup blockchain to see if the newly advertised routes in the transaction alters their routing paths. If true, they will observe the original path and its corresponding prefix. Next, they will locate the true owner of the prefix through the global blockchain $\mathcal{B}_{A}$. Accordingly, they will be able to detect that the newly announced prefix does not belong to the true owner, therefore, it is malicious. As long as 50\% ASes in a subgroup and 50\% of total subgroups behave honestly, the hijacking attempt can be detected and prevented in time. 

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.45\textwidth]{fig/123.pdf}
%\vspace{-12mm}
\caption{Timeline of Youtube Hijacking. Notice that within one minute of the announcement, 9 ASes had changed their routes, and within 20 minutes 97 ASes were redirecting their traffic to AS17577.} 
\label{fig:YThijack}
\end{center}
\end{figure}

Compromising 50\% of ASes within a subgroup can be costly in practice. In all the well-known attacks that have been launched against ASes, only one AS or ISP has been found to be the miscreant. Therefore, in practical settings, even if the subgroup size is small, a collusion of 50\% ASes is highly improbable. Furthermore, the adversary will also need support from 50\% of the total number of subgroups. Therefore, for a successful attack, the adversary would require half of the total ASes in the world to be on its side. Considering the associated cost, we conclude that \rc provides high security guarantees in adversarial settings.  

{\color{blue}
\section{\rc Deployment and Evaluation}\label{sec:simulation}
In this section, we evaluate the performance of \rc by deploying a blockchain testbed that supports PoS, PoET, and {\em Clique}. Considering $K$=298, we set up 298 nodes in Docker containers and deployed them across five different cities in the world including San Francisco, New York, Singapore, London, and Frankfurt. The motivation to set up nodes across different cities was to obtain realistic values for transaction confirmation by acknowledging propagation delay over the Internet. The testbed nodes were deployed on the {\em digital ocean data center}, which is cloud service provider that hosts its data centers globally. All nodes in the data center were assigned a public IP address and the IP addressing mapping was specified in the Docker configuration file. The Docker containers were aggregated in servers and each server had an Intel Xeon processor with 16GB RAM, and 500GB hard drive.


To enable communication among the blockchain nodes, we set up a NodeJS-based communication framework that specified the overlay topology among nodes. We also installed a middleware at each container that encoded the rules of the three consensus protocol. Each node used HTTP protocol with GET and POST methods to exchange data (\ie transactions and blocks) with other nodes. To minimize delay in the overlay communication model, we set up a completely-connected overlay topology. 


\begin{figure}[t]
\begin{center}
\includegraphics[width=0.45\textwidth]{fig/rc_one.pdf}
\caption{The subgroup consensus time $\mathcal{T}_{K}$ and the global consensus time $\mathcal{T}_{A}$ for the three consensus protocols. Our results show that {\em Clique} has the minimum consensus time, making it the ideal candidate for \rc.  } 
\label{fig:simPartial}
\end{center}
\end{figure}

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.45\textwidth]{fig/rc_two.pdf}
\caption{Maximum transaction throughput for all the three consensus protocols at the subgroup level and the global level. Our results show that {\em Clique} achieves the maximum throughput.  } 
\label{fig:simComplete}
\end{center}
\end{figure}


Next, we encoded the rules of each consensus protocol in our \rc testbed. For PoS, we randomly assigned tokes between the range of 100-10,000 to each node. For simplicity, we incorporated stakes for the block within the block header. As a result, in each round, nodes ordered transactions in the block with a random stake value and broadcast the block to all the other nodes in the network. Upon receiving different blocks from the network, a node selected the block that had the highest stakes specified in the block header. 

In order to feasibly implement PoET, instead of using Intel SGX, we relaxed the trust model and implemented random waiting time for blocks at each node. We pursued this approach to avoid the costly implementation of Intel SGX. In practice, ASes can easily afford to set up a node with Intel SGX. In our PoET implementation, a random waiting time was allocated to each node and once the waiting time expired, the node released a new block. To avoid forks, we calibrated the waiting times using a global clock. For {\em Clique} implementation, we followed a round-robin scheme to select a primary replica for each round. Furthermore, in each block, we specified the next primary replica that to order transactions and broadcast a block.  


To summarize, we set up 298 blockchain nodes across five different cities and implemented three different consensus protocol. Our testbed represented a subgroup of ASe that approved new BGP routes proposed by ASes within the subgroup. Since a BGP announcement is $\approx$0.5MB in size~\cite{BGPMTUmi97:online}, therefore, we set the block size at 0.5MB and calculated the end-to-end block confirmation time. For simplicity, we set each block to contain only one transaction which enables faster route validation. We calculated the global consensus time $\mathcal{T}_{A}$ as the time taken by $K/2$ subgroups to return a valid response to the global primary. Since each subgroup process transactions in parallel, therefore, $\mathcal{T}_{A}$ can be approximated as $2\times\mathcal{T}_{K}$.

\BfPara{Results} In~\autoref{fig:simPartial} and \autoref{fig:simComplete}, we show results obtained from our testbed implementation. \autoref{fig:simPartial} shows the subgroup consensus time $\mathcal{T}_{A}$ and the global consensus time for PoS, Clique, and PoET. We found that in a subgroup of 298 ASes, PoS, Clique, and PoET confirmed the transaction in 7.6, 5, and 14.1 milliseconds, respectively. Similarly, the global consensus time for the three protocols was 15.2, 10, and 28.2 milliseconds, respectively. The results show that {\em Clique} has the minimum consensus time which makes it the most suitable protocol for \rc. 

In \autoref{fig:simComplete}, we report the maximum transaction throughput for each protocol. At the subgroup level, PoS, {\em Clique}, and PoET achieved a throughput of 129, 200, and 70 transactions per second, respectively. At the global layer, the three protocols achieved a throughput of 64.5, 100, and 35 transactions per second, respectively. Since each transaction is a new route announcement, the results show that {\em Clique} can globally process up to 100 BGP announcements in one second, making it highly scalable.


}



We now evaluate the testbed results in light of our threat model \textsection\ref{sec:tm}. In a  partial hijack, only the consensus from the subgroup primaries is sufficient to detect the hijacking attack and neutralize it. Since the partial hijacking attack reflects a double-spending attack in the global blockchain, subgroup primaries can effectively query the blockchain and notify the global primary. Our results in~\autoref{fig:simPartial} show that the minimum subgroup consensus time is 5 milliseconds which can be achieved by implementing {\em Clique} in \rc. 

To prevent a complete hijacking attack, \rc acquires consensus of subgroups and ASes within a subgroup. Our results \autoref{fig:simPartial} shows that the minimum global consensus time is 10 milliseconds. Although, the consensus time over the complete hijacking attack is higher than the partial hijacking attack, considering the timings of real world attacks, this is tolerable. 


{\color{blue}
To further evaluate the effectiveness of \rc, we contrast the consensus time with the timings of Youtube's attack shown in \autoref{fig:YThijack}. It can be observed that during the attack duration, within 1 minute, 9 ASes were hijacked and within 20 minutes, 97 ASes were hijacked. However, our results in~\autoref{fig:simPartial}, show that all consensus protocols have a global consensus time less than 200 milliseconds. Therefore, the BGP attack can be easily neutralized using any of the three protocols which makes \rc highly effective in practice. \rc will notify the AS operators about the malicious route before the AS adopts that route and directs its traffic .} 


\section{Discussion}\label{sec:discussion}
One limitation of our work is the assignment of ASes within subgroups. To achieve ideal results, we show how subgroups can be structured to obtain consensus in minimum time (\autoref{eq:4}), however, in practice this may not be as close to the ideal situation. We group ASes based on geographical proximity. However, in the real world~\cite{LiangBXH11}, ASes may have conflicting interests or policies that may prevent them from being part of the same subgroup that also contains their competing ASes. However, as we mentioned earlier, geographical proximity is one policy, among others, that be used to construct \rc. As such, subgroup structure is agnostic of the underlying policy as long as it shares a single ledger.


Furthermore, a subgroup size can vary depending upon its construction policy. While obtaining consensus from 50\% ASes is pertinent to the transaction verification, however, reducing their number will reduce the latency. A transaction can be processed with agreement of fewer replicas, provided that the system has a strong trust model. We view this as an avenue for future research where the performance of \rc can be evaluated based upon varying subgroup size, structure, and policy. Finally, \rc can be incrementally deployed from a small group of ASes to all ASes over the Internet. In this paper, we provide a roadmap towards secure routing through immutable route management. This can be bootstrapped at a small scale and later adapted by entities which find it useful. 


\section{Related Work}\label{sec:rw}
In this section, we review notable efforts done to secure Internet routing protocols against well known attacks. Towards blockchain-based secure BGP routing Xing~\etal\cite{XingWW18} proposed  {\em BGPcoin}; a smart contract driven BGP framework that is implemented over Ethereum network. {\em BGPcoin} reduces the possibility of BGP prefix hijacking by providing secure BGP advertisements through smart contract enabled authentication. Hari \etal~\cite{HariL16} also proposed a blockchain-based secure BGP routing. They also identified caveats in using RPKI in the decentralized architecture of ASes. However, their proposal did not include a design blueprint that can be effectively used among ASes. Chang~\etal\cite{ChangVWKLSL11} proposed a behavioral assumption scheme, called {\em AS-TRUST} to design ASes reputation. {\em AS-TRUST} provides probabilistic trust for the ASes by evaluating their prior broadcasts and classify the outcomes based on a reputation function. Towards blockchain-based secure Domain Name Systems (DNS), Liu~\etal\cite{LiuLCHXW18} proposed a data storage method, called DecDNS that creates multiple DNS nodes in parallel to address single point-of-failure in DNS resolution. 

There has been extensive research carried out to secure BGP without the use of blockchains. Hu~\etal\cite{HuWL15} proposed Cooperative Information Sharing Model (CoISM) to improve shortcomings of information sharing through BGP monitoring. CoISM does not modify the current processing of BGP and can be implemented to validate real BGP routes and detect fake BGP routes. Moreover, it can be deployed in various inter-domain management applications, such as intrusion detection and failure analysis of routing. Camacho~\etal\cite{CamachoGBV13} proposed BGP eXtended Multipath (BGP-XM) for transit Autonomous Systems. BGP-XM uses algorithms including K-Best Route Optimizer  to strengthen BGP multi-path routing. BGP-XM does not violate BGP functionalities when selecting routes among different ASes paths. Schlamp~\etal\cite{SchlampHJCB16} proposed a ``Hijacking Event Analysis Program'' {\em HEAP}; to filter data sources and rate validity of BGP sub-prefixes in order to defend against hijacking. 





\section{Conclusion}\label{sec:conclusion}
In this paper we present a blockchain-based secure BGP routing system called \rc. \rc uses a hierarchical blockchain structure and three consensus protocols to facilitate fast and tamper-proof route management. While the blockchain ledger provides a validation source for all prefixes, the consensus protocols enable swift consensus among ASes over the nature of the prefix. Combined, these two properties enable \rc to act as standalone security service that can be incrementally deployed in parallel with current operations of ASes. We develop a blockchain testbed to evaluate the effectiveness of \rc using PoS, {\em Clique}, and PoET consensus protocols. Our results show that \rc is capable of preventing a BGP attack in all three protocols with {\em Clique} being the most suitable protocol choice due to low consensus time and a high throughput. 


% \BfPara{Acknowledgement:}This work is supported by Air Force Material Command award FA8750-16-0301 and Global Research Lab program of the National Research Foundation NRF-2016K1A1A2912757.




\bibliography{references.bib,conf.bib}




\end{document}

